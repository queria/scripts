#!/bin/bash

#set -x

OURDIR="$HOME/.cache/dmenu_hist"
if [[ ! -d "$OURDIR" ]]; then
    if [[ -f "$OURDIR" ]]; then
        mv "$OURDIR" "$OURDIR-bup"
        mkdir -p "$OURDIR"
        mv "$OURDIR-bup" "$OURDIR/history"
    else
        mkdir -p "$OURDIR"
    fi
fi
HIST="$OURDIR/history"
CACHE="$OURDIR/cache"


##### BASIC help/args section #####

if [[ "$1" == "--help" ]]; then
    cat <<EOF

$(basename $0) [--edit]

    Launch dmenu with choices built from all executables
    from folders in PATH, but prefer those already picked before,
    with last choice provided as first option.

    --edit   open history file [$HIST] in editor

    any other args will be passed directly to dmenu call
    for possibilities see dmenu(1).
EOF
    exit
fi

if [[ "$1" == "--edit" ]]; then
    if [[ -z "$EDITOR" ]]; then
        echo "You did not set $$EDITOR .. using vi"
        EDITOR=/usr/bin/vi
    fi
    exec $EDITOR $HIST
fi


##### FIND EXECUTABLES IN PATH #####

## get the modification time of latest changed
## directory in path
LASTCHANGE=$(( IFS=:
for p in $PATH; do
    stat --format "%Z" $p
done
) | sort -r| head -n1)

## if we have cache and it is older, remove it
[[ -f "$CACHE" && $LASTCHANGE -gt $(stat --format "%Z" $CACHE) ]] && rm $CACHE

if [[ ! -f "$CACHE" ]]; then
    # if we dont have cache, lets create one
    CACHE_TMP="$(mktemp --suffix qdmenu)"
    trap "rm $CACHE_TMP" EXIT
    ( IFS=:
    for p in $PATH; do
        find -L $p -maxdepth 1 -type f -executable -printf "%f\n" >> $CACHE_TMP 2> /dev/null
    done
    )
    sort -u $CACHE_TMP > $CACHE
fi


##### CALL DMENU TO GET USER CHOICE #####

touch "$HIST"
CHOICE=$((tac $HIST; grep -v -f $HIST $CACHE) | dmenu "$@")
[[ -z "$CHOICE" ]] && exit


##### SAVE USER CHOICE IN HISTORY #####

sed -i "/^$CHOICE$/d" $HIST
echo $CHOICE >> $HIST


##### EXECUTE USER CHOICE #####
$CHOICE &
